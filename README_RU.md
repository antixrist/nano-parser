# nano-parser
Пакет, предназначенный для упрощения парсинга тегированных шаблонных строк.

## Установка
```bash
npm install --save 'nano-parser';
```

## Использование
```javascript
    const {
        any,
        deffered,
        end,
        find,
        next,
        optional,
        repeat,
        required,
        sequence
    } = require('nano-parser');

    const parser = find(/[a-z]+/);
    parser.parse('abcd'); // abcd
    parser.parse('ab1cd'); // ab
    parser.parse('1abcd'); // undefined
```

## Примеры использования:
* [es6x - реализация возможностей jsx на чистом javascript](https://github.com/vasiliy-lector/es6x)

## Введение
С помощью nano-parser Вы можете создавать сложные парсеры, комбинируя простые. Есть возможность трансформировать результаты с помощью метода **then**, а так же кешировать результаты для ускорения повторной обработки.

### Элементарные парсеры
**find**, **next** и **end** наиболее простые парсеры. **find** предназначен для поиска строк или регулярных выражений. **next** и **end** используются при парсинге массива строк (актуально для разбора шаблонных строк)

### Комбинаторы
**any**, **sequence** и **repeat** предназначены для комбинирования других парсеров друг с другом

### Вспомогательные парсеры
**optional**, **required** и **deffered** являются вспомогательными. Они, соответственно, делают необязательным наличие парсера, строго обязательным, а **deferred** служит для возможности обращения к парсеру из самого себя.

### Класс Parser
Все парсеры при создании возвращают instance класса **Parser**. Поэтому имеют один и тот же интерфейс. Метод **exec** - является внутренним - для вызова из других парсеров. Пользователю доступен метод **parse**. Метод **parse** принимает первым параметром строку или массив строк, которые необходимо распарсить, вторым параметром опционально значения values, которые будут доступны вторым же параметром из метода **then**. Для кеширования результатов предназначен метод **useCache**.
